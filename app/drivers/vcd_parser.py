import re

class VCDParser:
    """
    Parses .vcd files generated by cmot to calculate timing delays.
    Simulates libvcd.py functionality.
    """
    
    def __init__(self, filename: str):
        self.filename = filename
        self.channels = {} # Map name/id to current value
        self.events = []   # List of (time, channel_id, value)

    def parse(self):
        """Reads the VCD and extracts timestamped events."""
        try:
            with open(self.filename, 'r') as f:
                lines = f.readlines()
        except FileNotFoundError:
            return

        current_time = 0.0
        
        for line in lines:
            line = line.strip()
            if not line: continue
            
            # Time marker (e.g. #100000) -> nanoseconds
            if line.startswith('#'):
                try:
                    # Convert ns to seconds
                    current_time = float(line[1:]) * 1e-9 
                except ValueError: pass
                
            # Value change (e.g. 160 or 060 or b1 60)
            # We look for single bit changes: "1<id>" or "0<id>"
            elif line.startswith('0') or line.startswith('1'):
                if len(line) > 1:
                    val = int(line[0])
                    chan_id = line[1:]
                    self.events.append((current_time, chan_id, val))

    def get_rising_edge_time(self, channel_id: str) -> float:
        """
        Finds the first time the specified channel goes from 0 to 1.
        Returns 0.0 if not found.
        """
        # Simple state machine
        last_val = 0
        for time_s, chan, val in self.events:
            if chan == channel_id:
                if last_val == 0 and val == 1:
                    return time_s
                last_val = val
        return 0.0

    def get_delay(self, launch_id: str, trigger_id: str) -> float:
        """Calculates (Trigger Time - Launch Time)."""
        t_launch = self.get_rising_edge_time(launch_id)
        t_trigger = self.get_rising_edge_time(trigger_id)
        
        # If parsing fails (or simulation), return a safe default or 0
        if t_launch == 0 and t_trigger == 0:
            return 0.0
            
        return t_trigger - t_launch